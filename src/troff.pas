unit troff;

{$INCLUDE defines.inc}


interface
   uses descriptions;

Procedure OutputTroff(Var F:System.Text; Const Desc:TFunctionDesc; Const FileName:AnsiString);

Function ParseTroff(Troff:AnsiString; Out Desc:TFunctionDesc):sInt;
Function StripTroff(Const Source:AnsiString):AnsiString;


implementation
   uses SysUtils, utils;

Procedure OutputTroff(Var F:System.Text; Const Desc:TFunctionDesc; Const FileName:AnsiString);
begin
   Writeln(F, '.\" file autogenerated by fpman');
   Writeln(F, '.TH "fp-',LowerCase(Desc.Name),'" 3 "', Desc.GeneratedOn, '" "fpman" "Free Pascal Programmer''s Manual"');
   
   Writeln(F, '.SH NAME');
   Write(F, Desc.Name);
   If(Desc.Summary <> '') then Write(F, ' - ', Desc.Summary);
   Writeln(F);
   
   If((Desc.Package_ <> '') OR (Desc.Unit_ <> '') OR (Desc.File_ <> '')) then begin
      Writeln(F, '.SH LOCATION');
      
      If(Desc.Package_ <> '') then Write(F, 'package \fB', Desc.Package_, '\fR, ');
      If(Desc.Unit_ <> '') then Write(F, 'unit \fB', Desc.Unit_, '\fR');
      
      If(Desc.File_ <> '') then begin
         Write(F,', file \fB', Desc.File_, '\fR');
         If((Desc.Line_ <> '') AND (Desc.Line_ <> '0')) then Write(F, ', line ', Desc.Line_)
      end;
      
      Writeln(F)
   end;
   
   If(Desc.Declaration <> '') then begin
      Writeln(F,'.SH SYNOPSIS');
      Writeln(F, Desc.Declaration)
   end;
   
   If(Desc.Inheritance <> '') then begin
      Writeln(F, '.SH INHERITANCE');
      Writeln(F, Desc.Inheritance);
   end;
   
   If(Desc.Description <> '') then begin
      Writeln(F, '.SH DESCRIPTION');
      Writeln(F, Desc.Description)
   end;
   
   If(Desc.Classifiers <> '') then begin
      Writeln(F, '.SH NOTES');
      Writeln(F, 'This identifier is \fI', Desc.Classifiers, '\fR.')
   end;
   
   If(Desc.Errors <> '') then begin
      Writeln(F, '.SH ERRORS');
      Writeln(F, Desc.Errors)
   end;
   
   If(Desc.SeeAlso <> '') then begin
      Writeln(F, '.SH SEE ALSO');
      Writeln(F, Desc.SeeAlso)
   end;
   
   Writeln(F, '.SH FPMAN');
   Write(F, 'manpage autogenerated by \fIfpman\fR from ');
   If(ParamCount > 0)
      then Write(F, '\fB', ExtractFileName(FileName), '\fR')
      else Write(F, 'STDIN');
   Writeln(F, ' on ',FormatDateTime('yyyy-mm-dd, hh:nn', Now()),'.'#10);
end;


Function ParseTroff(Troff:AnsiString; Out Desc:TFunctionDesc):sInt;
Var
   Line: AnsiString;
begin
   ResetDesc(Desc);
   If(Not DeleteUntil(Troff, #10, @Line)) then Exit(0);
   
   Line := Trim(Line);
   If(Line <> '.\" file autogenerated by fpman') then Exit(0);
   
   If(Not DeleteUntil(Troff, '.SH NAME')) then Exit(-1);
   If(Not DeleteUntil(Troff, #10)) then Exit(-1);
   If(Not DeleteUntil(Troff, #10, @Line)) then Exit(-1);
   
   Line := Trim(Line);
   If(DeleteUntil(Line, ' - ', @Desc.Name)) then begin
      Desc.Summary := Line
   end else begin
      Desc.Name := Line;
      Desc.Summary := ''
   end;
   
   If(LeftStr(Desc.Name, Length('\fB')) = '\fB') then Delete(Desc.Name, 1, Length('\fB'));
   If(RightStr(Desc.Name, Length('\fR')) = '\fR') then Delete(Desc.Name, Length(Desc.Name) + 1 - Length('\fR'), Length('\fR'));
   
   If(Not DeleteUntil(Troff, '.SH LOCATION')) then Exit(+1);
   If(Not DeleteUntil(Troff, #10)) then Exit(+1);
   If(Not DeleteUntil(Troff, #10, @Line)) then Exit(+1);
   
   Line := Trim(Line);
   
   If(LeftStr(Line, Length('package')) = 'package') then begin
      Delete(Line, 1, Length('package') + 1);
      If(Not DeleteUntil(Line, ', ', @Desc.Package_)) then Desc.Package_ := Line;
      
      If(LeftStr(Desc.Package_, Length('\fB')) = '\fB') then Delete(Desc.Package_, 1, Length('\fB'));
      If(RightStr(Desc.Package_, Length('\fR')) = '\fR') then Delete(Desc.Package_, Length(Desc.Package_) + 1 - Length('\fR'), Length('\fR'));
   end;
   
   If(LeftStr(Line, Length('unit')) = 'unit') then begin
      Delete(Line, 1, Length('unit') + 1);
      If(Not DeleteUntil(Line, ', ', @Desc.Unit_)) then Desc.Unit_ := Line;
      
      If(LeftStr(Desc.Unit_, Length('\fB')) = '\fB') then Delete(Desc.Unit_, 1, Length('\fB'));
      If(RightStr(Desc.Unit_, Length('\fR')) = '\fR') then Delete(Desc.Unit_, Length(Desc.Unit_) + 1 - Length('\fR'), Length('\fR'));
   end;
   
   Exit(+1)
end;

Function StripTroff(Const Source:AnsiString):AnsiString;
begin
   Result := StringReplace(Source, '\fR', '', [rfReplaceAll]);
   Result := StringReplace(Result, '\fB', '', [rfReplaceAll]);
   Result := StringReplace(Result, '\fI', '', [rfReplaceAll])
end;

end.
